// 定义淹没水深变量
var _threeRenderer = null, lastSight = null, floodIndex, meshParams, meshLayers = [], firstFloodLoad = true;

/**
 * 载入淹没分析水质面
 * @param dataSource 数据来源
 * @param type 数据类型，1-polygon数据，2-featureLayer数据
 */
function loadFloodModel(dataSource, type) {
  require(
    [
      "water/earcut",
      'water/ThreeRenderer',
      'water/WaterRenderer',
      'esri/tasks/QueryTask',
      'esri/tasks/support/Query',
      'esri/geometry/support/webMercatorUtils',
      "esri/geometry/Polygon",
      'dojo/domReady!'
    ],
    function (
      earcut,
      ThreeRenderer,
      WaterRenderer,
      QueryTask,
      Query,
      webMercatorUtils,
      Polygon
    ) {
      var _view = view;
      if (type === 1) {
        loadPolygonData(dataSource);
      } else {
        loadLayerData(dataSource);
      }

      function renderWater(geo, height) {
        var water = new WaterRenderer(_view, geo, function (x, y, z) {
          return height;
        }, earcut);
        _threeRenderer.add(water);
      }

      function loadPolygonData(dataSource) {
        if (_threeRenderer) {
          _threeRenderer.destroy();
          _threeRenderer = null;
        }
        _threeRenderer = new ThreeRenderer(_view);

        var geometry, minHeight = 1, polygonList = [], polygon, rings = [];
        if (dataSource.length) {
          // dataSource.forEach((item, index) => {
          //   let geoHeight = item.high;
          //   if (index === 0) {
          //     minHeight = geoHeight;
          //   } else if (geoHeight < minHeight) {
          //     minHeight = geoHeight;
          //   }
          //   geometry = JSON.parse(item.geom);
          //   polygonList.push(new Polygon({
          //     type: "polygon",
          //     rings: geometry.length === 1 ? geometry[0] : geometry,
          //     spatialReference: {wkid: 3857}
          //   }));
          // });
          // polygonList.forEach((item) => {
          //   renderWater(item, minHeight);
          // })


          dataSource.forEach((item, index) => {
            geometry = JSON.parse(item.geom);
            geometry && geometry.length && geometry.forEach((geo) => {
              geo.length && geo.forEach((ring) => {
                rings.push(ring);
              })
            });

            if (rings.length) {
              polygon = new Polygon({
                type: "polygon",
                rings: rings,
                spatialReference: {wkid: 3857}
              });
              renderWater(polygon, item.high);
            }

            if (index === 0 && firstFloodLoad) {
              loadMeshModel(meshParams);
              firstFloodLoad = false;

              _view.goTo({
                // center: polygon.extent.center,
                center: [item.centerx, item.centery],
                zoom: 18,
                heading: getTanDeg(Math.tan(item.centerx / item.centery)),
                tilt: 65
              }, {
                duration: 3000
              });
            }
          })
        }
        layer.close(floodIndex);
      }

      function loadLayerData(dataSource) {
        if (_threeRenderer) {
          _threeRenderer.destroy();
          _threeRenderer = null;
        }
        _threeRenderer = new ThreeRenderer(_view);

        let query = new Query({
          where: '1=1',
          outFields: ["*"],
          returnGeometry: true
        });
        let queryTask = new QueryTask({
          url: dataSource
        });
        queryTask.execute(query).then(function (result) {
          var features = result.features;
          var polygon, minHeight = 1, polygonList = [];
          if (features.length) {
            // features.forEach((item, index) => {
            //   polygon = item.geometry;
            //   let geoHeight = Number.parseInt(item.attributes.high) || 5;
            //   if (index === 0) {
            //     minHeight = geoHeight;
            //   } else if (geoHeight < minHeight) {
            //     minHeight = geoHeight;
            //   }
            //   if (polygon.spatialReference.isWGS84) {
            //     polygon = webMercatorUtils.geographicToWebMercator(polygon);
            //   }
            //   polygonList.push(polygon);
            // });
            // polygonList.forEach((item) => {
            //   renderWater(item, minHeight);
            // })
            features.forEach((item, index) => {
              polygon = item.geometry;
              if (polygon.spatialReference.isWGS84) {
                polygon = webMercatorUtils.geographicToWebMercator(polygon);
                renderWater(polygon, Number.parseInt(item.attributes.high));
              }
            });
          }
        });
      }

      function getTanDeg(tan) {
        let result = Math.atan(tan) / (Math.PI / 180);
        result = Math.round(result);
        return result;
      }
    }
  );
}

function loadMeshModel(exparams) {
  require([
    "esri/layers/IntegratedMeshLayer",
    "esri/layers/SceneLayer"
  ], function (IntegratedMeshLayer, SceneLayer) {
    if (meshLayers.length) {
      map.removeMany(meshLayers);
    }
    if (exparams.url && exparams.url.length) {
      exparams.url.forEach((item) => {
        let type = exparams.params.symbol3d || 2;
        if (type === 1) {
          meshLayers.push(new IntegratedMeshLayer({
            url: item,
            elevationInfo: {
              mode: "absolute-height",
              offset: exparams.params.offset || 0,
              unit: "meters"
            }
          }))
        } else if (type === 2) {
          meshLayers.push(new SceneLayer({
            url: item,
            popupEnabled: false,
            elevationInfo: {
              mode: "absolute-height",
              offset: exparams.params.offset || 0,
              unit: "meters"
            }
          }))
        }
      });
      map.addMany(meshLayers);
    }
  })
}

function loadFloodAnalysis(item) {
  floodIndex = layer.load(2, {time: 10 * 1000, shade: [0.2, '#393D49']});

  let stcd = item.stcd || '520100000000000';
  let body = {
    interface: "com.ec.ws.service.def.monitoring.MonitorObjectService",
    method: "getModelReappearByStcd",
    args: [stcd]
  };
  ajaxCallJson(body, "/rpc", ({data}) => {
    if (data && data.length) {
      lastSight = view.viewpoint.clone();
      meshParams = item.exparams;
      // loadMeshModel(item.exparams);
      $("#calendar-main").hide();
      $("#flood-back").show();
      note.notify("flood.analysis", data);
      note.notify("hide.player");
    } else {
      layer.close(floodIndex);
      layer.msg("暂无该地区淹没分析图层数据...");
    }
  });
}

function onFloodAnalysisBack() {
  view.viewpoint = lastSight;
  firstFloodLoad = true;
  layer.close(floodIndex);
  if (meshLayers.length) {
    map.removeMany(meshLayers);
    meshLayers = [];
  }
  $("#calendar-main").show();
  $("#flood-back").hide();
  if (_threeRenderer) {
    _threeRenderer.destroy();
    _threeRenderer = null;
  }
  if(lastSight){
    note.notify("flood.back");
  }
  note.notify("box.show");
}

/**
 * 洪水演进单独视图处理
 */
$(function () {
  let river_net = false, base = null, need = ["layer_base_1", "layer_base_39"];
  note.on("subject.change", (event, layer) => {
    if (layer && layer.id === "3") {
      // 飞入河网总视图
      view.goTo({
        center: [107.67, 26.65],
        heading: 0,
        tilt: 0,
        zoom: 6,
      });
      base = map.basemap;
      // 载入河网
      note.notify("layer.basic.switch", need, true);
      // 载入底图
      switchBaseMap(1);
      river_net = true;
    } else if (river_net === true) {
      if (base !== map.basemap) {
        delMapLayersById('GoogleAnnoLayer');
        map.basemap = base;
      }
      river_net = false;
      note.notify("layer.basic.switch", need, false);
    }
  });
});