// 前端公共方法
/**
 * 绑定ajax的CSRF验证设置
 */
// var ctoken = $.cookie('csrfToken');

function csrfSafeMethod(method) {
  // these HTTP methods do not require CSRF protection
  return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}

$.ajaxSetup({
  // beforeSend: function (xhr, settings) {
  //   if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
  //     xhr.setRequestHeader('x-csrf-token', ctoken);
  //   }
  // }
});

/**
 * 封装ajax
 * @param {*} param 请求参数
 * @param {*} url 请求地址
 * @param {*} type 请求类型POST、PUT、DELETE、GET等
 * @param {*} done 请求成功后的回调函数
 */
function ajaxCallJson(param, url, done, error) {
  // console.log("request: ", url);
  return $.ajax({
    type: 'post',
    dataType: 'json',
    url: url,
    data: JSON.stringify(param),
    contentType: "application/json; charset=utf-8",
    success: function (data, status) {
      // console.log("response:", url, param, data);
      try {
        if (data) {
          if (data.resflag === false && param.prevent !== true) {
            layer.msg(data.errorinfo || "请求出错，请稍后再试！");
            if (error) return error(data.errorinfo);
          }
          if (data.flag || data.resflag) {
            if (done) {
              done(data)
            }
          } else {
            done(data, data.error || data.errorinfo);
            if (data.error)
              throw new Error(url + data.error);
            else if (data.errorinfo)
              throw new Error(url + data.errorinfo);
            //layer.msg(data.error||data.errorinfor, {time: 2000})
          }
        } else {
          if (data && data.error) {
            done(null);
          }
          throw new Error("response data is null");
          //layer.msg(data.error, {time: 2000})
        }
      } catch (err) {
        console.error(url, param, err);
        if (error) error(err);
      }
    },
    error: function (jqXHR, textStatus, errorThrown) {
      if (errorThrown != 'abort') {
        console.error(url, param, arguments);
        if (error) error();
        throw new Error(url + ":" + errorThrown);
        //layer.msg("请求出错:"+errorThrown, {time: 2000})
      }
    }
  });
}

// var ajaxCallJson = function (param, url, type, done) {
//     $.ajax({
//         type: type,
//         dataType: 'json',
//         url: url,
//         data: JSON.stringify(param),
//         contentType: "application/json; charset=utf-8",
//         success: function (data, state) {
//             console.log(url, param, data);
//             if (param.prevent !== true && data.resflag === false) {
//                 return layer.msg("请求出错，请稍后再试！");
//             }
//             try {
//                 if (data) {
//                     done(data);
//                 }
//             } catch (e) {
//                 layer.msg(e, {time: 2000})
//             }
//         },
//         error: function (err) {
//             layer.msg("请求出错:" + err, {time: 2000})
//         }
//     })
// }


var toolboxIcon = "image://images/downloadimages.png";
var toolboxIconSize = 24;
var toolboxIconbackgroundColor = "rgba(9, 25, 57, 0.99)"
/**
 * 对数组对象排序
 * @param name  排序字段
 * ep: data.sort(by("year"))
 */
var by = function (name) {
  return function (o, p) {
    var a, b;
    if (typeof o === "object" && typeof p === "object" && o && p) {
      a = o[name];
      b = p[name];
      if (a === b) {
        return 0;
      }
      if (typeof a === typeof b) {
        return a < b ? -1 : 1;
      }
      return typeof a < typeof b ? -1 : 1;
    } else {
      throw ("error");
    }
  }
}


/*判断空或者undefined*/
var isEmpty = function (str) {
  return str == undefined || str == null || $.trim(str) == "";
};

/*
 *  方法:Array.remove(index) 通过遍历,重构数组
 *  功能:删除数组元素.
 *  参数:dx删除元素的下标.
 */
// Array.prototype.remove = function (index) {
//   if (isNaN(index) || index > this.length) {
//     return false;
//   }
//   for (var i = 0, n = 0; i < this.length; i++) {
//     if (this[i] != this[index]) {
//       this[n++] = this[i]
//     }
//   }
//   this.length -= 1
// }
/*
 *  方法:Array.remove(value) 通过遍历,重构数组
 *  功能:删除数组元素.
 *  参数:value删除元素值.
 */
// Array.prototype.removeByValue = function (value) {
//   for (var i = 0; i < this.length; i++) {
//     if (compare(this[i], value)) {
//       this.splice(i, 1);
//       break;
//     }
//   }
// }
var compare = function (x, y) {
  // If both x and y are null or undefined and exactly the same
  if (x === y) {
    return true;
  }

  // If they are not strictly equal, they both need to be Objects
  if (!(x instanceof Object) || !(y instanceof Object)) {
    return false;
  }

  //They must have the exact same prototype chain,the closest we can do is
  //test the constructor.
  if (x.constructor !== y.constructor) {
    return false;
  }

  for (var p in x) {
    //Inherited properties were tested using x.constructor === y.constructor
    if (x.hasOwnProperty(p)) {
      // Allows comparing x[ p ] and y[ p ] when set to undefined
      if (!y.hasOwnProperty(p)) {
        return false;
      }

      // If they have the same strict value or identity then they are equal
      if (x[p] === y[p]) {
        continue;
      }

      // Numbers, Strings, Functions, Booleans must be strictly equal
      if (typeof (x[p]) !== "object") {
        return false;
      }

      // Objects and Arrays must be tested recursively
      if (!Object.equals(x[p], y[p])) {
        return false;
      }
    }
  }

  for (p in y) {
    // allows x[ p ] to be set to undefined
    if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
      return false;
    }
  }
  return true;
};

//判断两个对象是否相等
function isObjectEquals(x, y) {
  var in1 = x instanceof Object;
  var in2 = y instanceof Object;
  if (!in1 || !in2) {
    return x === y;
  }
  if (Object.keys(x).length != Object.keys(y).length) {
    return false;
  }
  for (var p in x) {
    var a = x[p] instanceof Object;
    var b = y[p] instanceof Object;
    if (a && b) {
      return equals(x[p], y[p]);
    } else if (x[p] !== y[p]) {
      return false;
    }
  }

  return true;
}


// 对undefined和null处理
var handlerUndefinedOrNull = function (str) {
  if (isEmpty(str)) {
    return "";
  }
  return str;
};
var dateViewCommond = function (value) {
  if (isEmpty(value)) {
    return "";
  }
  value = value + "";
  var result = value;
  var reg = new RegExp("^[0-9]*$");
  var str = value;
  str = str.replace(/-/g, "").replace(/:/g, "").replace(/ /g, "");
  if (str.length > 0 && !isNaN(str)) {
    //var flag = true;
    //for(var i=0;i<str.length;i++) {
    //    var chr = str.charAt(i);
    //    if (reg.test(chr))
    //        continue;
    //    flag = false;
    //    break;
    //}
    //if(flag) {
    result = value.substring(0, 4) + "年" + parseInt(value.substring(5, 7)) + "月" + parseInt(value.substring(8, 10)) + "日" + parseInt(value.substring(11, 13)) + "时"
    //}
  }
  return result;
}

//格式化数组值
function formatArrayData(array, value) {
  //后端处理
  // var number=value?value:2;
  // for(var i=0;i<array.length;i++){
  //     if(array[i]!=undefined&&array[i]!="-"&&array[i]!=null&&typeof array[i] =='number'){
  //         array[i]=array[i].toFixed(number);
  //     }
  // }
  return array;
}

//格式化浮点数
function formatDoubelData(data, value) {
  var number = value ? value : 2;
  if (data != undefined && data != "-" && data != null && typeof data == 'number') {
    data = data.toFixed(number);
  }
  return data;
}

var createBootstrapTable = function (id, _table, window, _pagination, nodeflg, done) {
  var height = "";
  if (nodeflg == "2") {
    height = window.body.find('#' + id).parent().parent().height() - 60;
  } else {
    height = window.body.find('#' + id).parent().height() - 20;
  }
  var data = _table.data;
  if (!data) {
    data = new Array();
  }
  for (var i = 0; i < data.length; i++) {
    data[i].id = i + 1;
  }
  var columns = _table.columns;
  var flag = true;
  if (!columns) {
    columns = new Array();
  }
  for (var i = 0; i < columns.length; i++) {
    if (columns[i].field == "id") {
      flag = false;
      break;
    }
  }
  if (flag) {
    var temp = {
      visible: false,
      field: 'id',
      title: '序号'
    }
    columns.push(temp);
  }
  ;
  var page = true;
  if (_pagination != undefined)
    page = _pagination;
  var option = {
    height: height,
    columns: columns,
    data: data,
    showHeader: true,
    pagination: page,
    uniqueId: "id",
    pageNumber: 1,
    pageSize: 10,
    pageList: [10]

  }
  $('#' + id).bootstrapTable('destroy');
  $('#' + id).bootstrapTable('load', _table.data);
  $('#' + id).bootstrapTable(option);
  $('#' + id).unbind("click-cell.bs.table").bind("click-cell.bs.table", function (filed, value, ele, data) {
    var filed = value;
    if (filed == "noteContent") {
      var allMsg = data.noteAllContent;
      layer.alert(allMsg, {
        title: "详细信息"
      });
    }
    if (done) {
      done(filed, data)
    }
  });
  window.resizecbfn(function () {
    resizeWarningContent(window)
    var height = getTableHeight(id + "-container");
    $('#' + id).bootstrapTable('resetView', {
      height: height
    });
  })
}

/**
 * 横断面创建
 * data:  pointArr:断面线   pointList:标注对象(指标)[{name:名称,value:值}] zs:[{z:水位,tm:时间}]
 */
var createSectionView = function (domId, data, myWindow) {
  if (!data.pointArr || data.pointArr.length == 0)
    return;
  var myChart = echarts.init(document.getElementById(domId));

  var tempList = new Array();
  var xLineList = new Array();
  for (var i = 0; i < data.pointArr.length; i++) {
    tempList.push(data.pointArr[i][1]);
    xLineList.push(data.pointArr[i][0]);
  }
  for (var i = 0; i < data.pointList.length; i++) {
    tempList.push(data.pointList[i].value);
  }
  var maxMinY = getMaxMinData(tempList);
  if (data.zs.maxZ > maxMinY.max)
    maxMinY.max = Math.round(data.zs.maxZ) + 1;

  var xVminY = 0,
    xMinValue = 0,
    xMaxValue = 0;
  var tempMin = Math.min.apply(0, tempList);
  for (var i = 0; i < data.pointArr.length; i++) {
    if (parseInt(data.pointArr[i][1]) == parseInt(tempMin))
      xVminY = data.pointArr[i][0];
    if (data.pointArr[i][0] < xMinValue)
      xMinValue = data.pointArr[i][0];
    if (data.pointArr[i][0] > xMaxValue)
      xMaxValue = data.pointArr[i][0];
  }

  var timeLineLabels = new Array();
  var timeLineIndex = 0,
    hasMax = false;
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0) {
    for (var i = 0; i < data.zs.zsList.length; i++) {
      if (data.zs.zsList[i].tm == data.zs.publishTm)
        timeLineIndex = i;
      var tempObj = {
        value: data.zs.zsList[i].tm,
        tooltip: {
          formatter: function (params) {
            return params.name;
          }
        },
        symbol: 'rect',
        symbolSize: 5
      };
      if (data.zs.zsList[i].start) {
        tempObj.symbolSize = 15;
        tempObj.symbol = 'diamond';
      }
      if (data.zs.maxZ && data.zs.maxZ == data.zs.zsList[i].z && moment(data.zs.zsList[i].tm).isAfter(data.zs.publishTm) && !hasMax) {
        hasMax = true;
        tempObj.symbolSize = 15;
        tempObj.symbol = 'triangle';
        tempObj.tooltip = {
          formatter: function (params) {
            return params.name + ' 最高水位:' + data.zs.maxZ + 'm';
          }
        };
      }
      timeLineLabels.push(tempObj);
    }
  }

  var markPointData = getMarkPointData(data.pointList, xVminY, (xMaxValue - xMinValue) * 0.2);

  var winBodyWidth = myWindow.body.width() - 10 - 150;
  var winBodyHeight = myWindow.body.height() - 10 - 80;
  var _scaleX = 0,
    _scaleY = 0;
  if (data.pointArr[data.pointArr.length - 1][0] % 10 > 0) {
    _scaleX = Math.floor(data.pointArr[data.pointArr.length - 1][0] / 10) + (data.pointArr[data.pointArr.length - 1][0] % 10) / 10;
  } else {
    _scaleX = data.pointArr[data.pointArr.length - 1][0] / 10;
  }
  ;
  if ((maxMinY.max - maxMinY.min) % 10 > 0) {
    _scaleY = Math.floor((maxMinY.max - maxMinY.min) / 10) + ((maxMinY.max - maxMinY.min) % 10) / 10;
  } else {
    _scaleY = (maxMinY.max - maxMinY.min) / 10;
  }
  ;
  var _height = (winBodyWidth / _scaleX) * _scaleY;
  var baseOption = {
    grid: {
      // left:75,
      // right:75,
      // width:winBodyWidth,
      // height:_height,
      // top: (winBodyHeight-_height)/2
      bottom: 80
    },
    xAxis: {
      name: '起点距(m)',
      splitLine: {
        show: false
      },
      // axisLabel:{show:false},
      // axisTick:{show:false},
      boundaryGap: false,
      //interval:10,
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    yAxis: {
      name: '高程(m)',
      max: maxMinY.max,
      min: maxMinY.min,
      //interval:10,
      splitLine: {
        show: false
      },
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    series: [{
      type: 'line',
      name: 'sectionLine',
      itemStyle: {
        normal: {
          opacity: 0
        }
      },
      areaStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      lineStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      data: data.pointArr,
      z: 1
    }, {
      type: 'line',
      name: 'index',
      markPoint: {
        silent: true,
        data: markPointData
      },
      z: 2
    }],
    title: {
      text: data.title,
      show: false
    },
    toolbox: {
      feature: {
        saveAsImage: {
          type: "jpg",
          backgroundColor: toolboxIconbackgroundColor,
          icon: toolboxIcon,
          excludeComponents: ['toolbox']
        }
      },
      itemSize: toolboxIconSize,
      right: "18",
    },
    //backgroundColor:"rgba(0, 102, 204, 0.3)"
  };
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0)
    baseOption.timeline = {
      axisType: 'category',
      autoPlay: false,
      playInterval: 1000,
      currentIndex: timeLineIndex,
      bottom: 0,
      data: timeLineLabels,
      label: {
        formatter: function (param) {
          return param;
        },
        textStyle: {
          color: '#FFF'
        }
      },
      lineStyle: {
        color: '#FFF',
        width: 0.5
      },
      controlStyle: {
        normal: {
          color: '#FFF',
          borderColor: '#FFF'
        }
      },
      itemStyle: {
        normal: {
          color: '#FFF',
          borderColor: '#FFF'
        }
      }
    }
  baseOption.tooltip = {};
  var options = getOptions(data, xLineList, tempMin, xVminY);
  myChart.setOption({
    baseOption: baseOption,
    options: options
  });
  if ($.inArray(myChart, chartArray) == -1) {
    chartArray.push(myChart);
  }
  myWindow.resizecbfn(function () {
    myChart.resize();
  });
}

/**
 * 纵断面创建
 * data:  pointArr:断面线   pointList:标注对象(指标)[{name:名称,value:值}] zs:[{z:水位,tm:时间}]
 */
var createVerticalSectionView = function (domId, data, myWindow) {
  if (!data.pointArr || data.pointArr.length == 0)
    return;
  var myChart = echarts.init(document.getElementById(domId));

  var tempList = new Array();
  var xLineList = new Array();
  for (var i = 0; i < data.pointArr.length; i++) {
    tempList.push(data.pointArr[i][1]);
    xLineList.push(data.pointArr[i][0]);
  }
  var maxMinY = getMaxMinData(tempList);

  var xVminY = 0;
  var tempMin = Math.min.apply(0, tempList);
  for (var i = 0; i < data.pointArr.length; i++) {
    if (data.pointArr[i][1] == tempMin)
      xVminY = data.pointArr[i][0];
  }

  var timeLineLabels = new Array();
  if (data.zs && data.zs.length > 0)
    for (var i = 0; i < data.zs.length; i++) {
      timeLineLabels.push(data.zs[i].tm);
    }
  var markPointData = getMarkPointData(data.pointList, xVminY);

  // var _width = myWindow.body.width()-10-150;
  // var _scaleX = 0,_scaleY = 0;
  // if(data.pointArr[data.pointArr.length-1][0]%10>0){
  //     _scaleX = data.pointArr[data.pointArr.length-1][0]/10 + 1;
  // }else{
  //     _scaleX = data.pointArr[data.pointArr.length-1][0]/10;
  // };
  // if((maxMinY.max-maxMinY.min)%10>0){
  //     _scaleY = (maxMinY.max-maxMinY.min)/10 + 1;
  // }else{
  //     _scaleY = (maxMinY.max-maxMinY.min)/10;
  // };
  // var _height = (_width/_scaleX)*_scaleY;
  var baseOption = {
    // grid:{
    //     left:75,
    //     right:75,
    //     width:_width,
    //     height:_height
    // },
    xAxis: {
      name: '起点距(m)',
      splitLine: {
        show: false
      },
      boundaryGap: false,
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    yAxis: {
      name: '高程(m)',
      max: maxMinY.max,
      min: maxMinY.min,
      splitLine: {
        show: false
      },
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    series: [{
      type: 'line',
      name: 'sectionLine',
      itemStyle: {
        normal: {
          opacity: 0
        }
      },
      areaStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      lineStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      data: data.pointArr,
      z: 1
    }, {
      type: 'line',
      name: 'index',
      markPoint: {
        silent: true,
        data: markPointData
      },
      z: 2
    }],
    title: {
      text: data.title,
      show: false
    },
    toolbox: {
      feature: {
        saveAsImage: {
          type: "jpg",
          backgroundColor: toolboxIconbackgroundColor,
          icon: toolboxIcon,
          excludeComponents: ['toolbox']
        }
      },
      itemSize: toolboxIconSize,
      right: "18",
    },
  };
  // if(data.zs&&data.zs.length>0)
  //     baseOption.timeline = {
  //         axisType: 'category',
  //         autoPlay: false,
  //         playInterval: 1000,
  //         bottom:0,
  //         data: timeLineLabels,
  //         label: {
  //             formatter: function (param) {
  //                 return param;
  //             },
  //             textStyle:{color:'#FFF'}
  //         },
  //         lineStyle:{color:'#FFF'}
  //     }
  var options = getOptions(data, xLineList, tempMin, xVminY);
  myChart.setOption({
    baseOption: baseOption,
    options: options
  });
  if ($.inArray(myChart, chartArray) == -1) {
    chartArray.push(myChart);
  }
  myWindow.resizecbfn(function () {
    myChart.resize();
  });
}

/**
 * 大坝创建
 * data:  pointList:标注对象[{name:名称,value:值}] zs:[{z:水位,tm:时间}]
 *
 */
var createDamView = function (domId, data, win, clickType) {
  var myChart = echarts.init(document.getElementById(domId));
  //console.info(data);
  var pointList = [];
  var markPointData;
  if (win == "") {
    pointList = [];
    for (var i = 0; i < data.pointList.length; i++) {
      if (data.pointList[i].name == "正常蓄水位") {
        pointList.push(data.pointList[i])
      }
    }
    markPointData = getMarkPointData(pointList, 35);
  } else {
    markPointData = getMarkPointData(data.pointList, 35);
  }
  if (win != "") {
    // markPointData = markPointData.concat(createMarkPoint(55, data.min, '坝底高程'));
  }
  //console.info(markPointData);
  if (data.type == -1) {
    data.type = 5
  }
  var damImg = '/images/dam/' + data.type + ".png",
    waterLen = 0;
  var width = $("#" + domId).width();
  var height = $("#" + domId).height();
  var gridWidth;
  if (win == "") {
    if (data.type = 3) {
      gridWidth = width - 50;
    } else {
      gridWidth = width - 100;
    }
  } else {
    gridWidth = width - 160
  }
  var gridHeight = height,
    oldMax = data.max,
    elXVal, yPu, yPd;
  if (data.type == 0 || data.type == 1 || data.type == 2 || data.type == 6 || data.type == 7) {
    elXVal = 65;
    waterLen = 54.2;
  } else if (data.type == 3 || data.type == 4) {
    waterLen = 54.8;
    elXVal = 62;
  } else if (data.type == 5) {
    elXVal = 65;
    waterLen = 58;
  } else if (data.type == 8 || data.type == 9) {
    elXVal = 52;
    waterLen = 49;
  }
  if (win != "") {
    markPointData = markPointData.concat(createMarkPoint(elXVal, data.max, '坝顶高程'));
  }
  //console.log(data.type);
  switch (data.type) {
    case 0:
      yPu = 0.334;
      yPd = 0.2;
      break;
    case 1: //OK
      yPu = 0.33;
      yPd = 14 / 50.22;
      break;
    case 2:
      yPu = 0.33;
      yPd = 14 / 50.22;
      break;
    case 3: //OK
      yPu = 0.165;
      yPd = 10 / 52.5;
      break;
    case 4:
      yPu = 0.150;
      yPd = 12 / 52.5;
      break;
    case 5: //OK
      yPu = 0.33;
      yPd = 4 / 14.6;
      break;
    case 6:
      yPu = 0.33;
      yPd = 4 / 14.6;
      break;
    case 7:
      yPu = 0.33;
      yPd = 4 / 14.6;
      break;
    case 8: //OK
      yPu = 0.2;
      yPd = 16 / 54.2;
      break;
    case 9:
      yPu = 0.16;
      yPd = 10 / 51.6;
      break;
    default:
      break;
  }
  data.min = parseInt(data.min - (data.max - data.min) * yPd);
  data.max = parseInt(data.max + (yPu * (data.max - data.min) / (1 - yPu)));

  var pxV = ""
  if (win == "") {
    switch (data.type) {
      case 0:
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 1: //OK
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 2:
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 3: //OK
        pxV = (height + 20) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 4:
        pxV = (height + 20) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 5: //OK
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 6:
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 7:
        pxV = (height + 150) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 8: //OK
        pxV = (height + 20) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      case 9:
        pxV = (height + 20) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
        break;
      default:
        break;
    }

  } else {
    pxV = (height - 80) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
  }
  gridHeight = (oldMax - data.min) * pxV;
  var baseOption = ""
  if (win == "") {
    baseOption = {
      grid: {
        left: 40,
        right: 10,
        bottom: 10,
        top: 60
      },
      backgroundColor: "rgba(9, 25, 57, 0)",
      xAxis: {
        splitLine: {
          show: false
        },
        min: 0,
        max: 100,
        boundaryGap: false,
        axisTick: false, //是否显示刻度
        axisLabel: false, //是否显示刻度标签
        nameTextStyle: {
          color: '#FFF'
        }
      },
      yAxis: {
        name: '高程(m)',
        max: data.max,
        min: data.min,
        splitLine: {
          show: false
        },
        nameTextStyle: {
          color: '#FFF',
          fontSize: 14
        },
        axisLine: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisTick: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisLabel: {
          textStyle: {
            color: '#FFF'
          }
        },
      },
      series: [{
        type: 'line',
        name: 'index',
        markPoint: {
          silent: true,
          data: markPointData
        },
        z: 3
      }, {
        name: 'waterLine',
        type: 'line',
        symbolSize: 0,
        areaStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        lineStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        z: 0
      }],
      title: {
        text: data.title,
        show: false
      },
      toolbox: {
        feature: {
          saveAsImage: {
            type: "jpg",
            backgroundColor: toolboxIconbackgroundColor,
            icon: toolboxIcon
          }
        },
        iconStyle: {
          normal: {
            color: '#fff', //设置颜色
          }
        },
        itemSize: toolboxIconSize,
        right: "18"
      },
      graphic: [{
        type: 'image',
        id: 'logo',
        left: 40,
        bottom: 10,
        z: 1,
        bounding: 'raw',
        style: {
          image: damImg,
          width: gridWidth,
          height: gridHeight,
          opacity: 1
        }
      }]
    };
  } else {
    baseOption = {
      grid: {
        left: 80,
        right: 80,
        bottom: 10,
        top: 70
      },
      backgroundColor: "rgba(9, 25, 57, 0)",
      xAxis: {
        splitLine: {
          show: false
        },
        min: 0,
        max: 100,
        boundaryGap: false,
        axisTick: false, //是否显示刻度
        axisLabel: false, //是否显示刻度标签
        nameTextStyle: {
          color: '#FFF'
        }
      },
      yAxis: {
        name: '高程(m)',
        max: data.max,
        min: data.min,
        splitLine: {
          show: false
        },
        nameTextStyle: {
          color: '#FFF'
        },
        axisLine: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisTick: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisLabel: {
          textStyle: {
            color: '#FFF'
          }
        },
      },
      series: [{
        type: 'line',
        name: 'index',
        markPoint: {
          silent: true,
          data: markPointData
        },
        z: 3
      }, {
        name: 'waterLine',
        type: 'line',
        symbolSize: 0,
        areaStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        lineStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        z: 0
      }],
      title: {
        text: data.title,
        show: false
      },
      toolbox: {
        feature: {
          saveAsImage: {
            type: "jpg",
            backgroundColor: toolboxIconbackgroundColor,
            icon: toolboxIcon
          }
        },
        itemSize: toolboxIconSize,
        right: "18"
      },
      graphic: [{
        type: 'image',
        id: 'logo',
        left: 80,
        bottom: 10,
        z: 1,
        bounding: 'raw',
        style: {
          image: damImg,
          width: gridWidth,
          height: gridHeight,
          opacity: 1
        }
      }]
    };
  }


  var options = new Array();
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0) {
    var tLabel = new Array(),
      textVal = '',
      timeLineIndex = 0,
      timeLineMarkPointData, hasMax = false;
    data.zs.zsList.forEach(function (value, index, array) {
      timeLineMarkPointData = markPointData;
      if (value.tm == data.zs.publishTm)
        timeLineIndex = index;
      var tempObj = {
        value: value.tm,
        tooltip: {
          formatter: function (params) {
            return params.name;
          }
        },
        symbol: 'rect',
        symbolSize: 5
      };
      if (value.start) {
        tempObj.symbolSize = 15;
        tempObj.symbol = 'diamond';
      }
      if (data.zs.maxZ && data.zs.maxZ == value.z && moment(value.tm).isAfter(data.zs.publishTm) && !hasMax) {
        hasMax = true;
        tempObj.symbolSize = 15;
        tempObj.symbol = 'triangle';
        tempObj.tooltip = {
          formatter: function (params) {
            return params.name + ' 最高水位:' + data.zs.maxZ + 'm';
          }
        };
        tempObj.itemStyle = {
          normal: {
            color: 'rgba(31, 156, 255, 1)'
          }
        };
      }
      tLabel.push(tempObj);

      timeLineMarkPointData = timeLineMarkPointData.concat(createMarkPoint(5, value.z, '水库水位'));
      timeLineMarkPointData.push({
        symbol: "rect",
        symbolSize: [130, 18],
        itemStyle: {
          normal: {
            color: 'rgba(128, 128, 128, 0)'
          }
        },
        coord: [20, value.z - (value.z - data.min) / 2],
        W: value.w,
        label: {
          normal: {
            show: true,
            formatter: function (param) {
              return '库容:' + param.data.W + '万m³';
            }
          }
        }
      });
      timeLineMarkPointData.push({
        symbol: "rect",
        symbolSize: [130, 18],
        symbolOffset: [0, '-300%'],
        itemStyle: {
          normal: {
            color: 'rgba(128, 128, 128, 0)'
          }
        },
        coord: [50, data.max + 5],
        W: value.w,
        label: {
          normal: {
            show: true,
            formatter: function (param) {
              return '时间:' + value.tm;
            }
          }
        }
      });
      options.push({
        series: [{
          type: 'line',
          name: 'nowZ',
          markPoint: {
            silent: true,
            data: timeLineMarkPointData
          },
          z: 3
        }, {
          name: 'waterLine',
          data: [
            [0, value.z],
            [waterLen, value.z]
          ]
        }]
      });
    });
    baseOption.tooltip = {};
    if (win == "") {
      baseOption.timeline = {
        axisType: 'category',
        autoPlay: false,
        playInterval: 1000,
        bottom: 1,
        currentIndex: timeLineIndex,
        data: tLabel,
        left: 60,
        right: 40,
        z: 10,
        label: {
          formatter: function (param) {
            return param;
          },
          textStyle: {
            color: '#0d686f'
          }
        },
        lineStyle: {
          color: '#0d686f'
        },
        controlStyle: {
          normal: {
            color: '#0d686f',
            borderColor: '#0d686f'
          }
        },
        itemStyle: {
          normal: {
            color: '#0d686f',
            borderColor: '#0d686f'
          }
        }
      }
    } else {
      baseOption.timeline = {
        axisType: 'category',
        autoPlay: false,
        playInterval: 1000,
        bottom: 10,
        currentIndex: timeLineIndex,
        data: tLabel,
        left: 80,
        right: 80,
        z: 10,
        label: {
          formatter: function (param) {
            return param;
          },
          textStyle: {
            color: '#0d686f'
          }
        },
        lineStyle: {
          color: '#0d686f'
        },
        controlStyle: {
          normal: {
            color: '#0d686f',
            borderColor: '#0d686f'
          }
        },
        itemStyle: {
          normal: {
            color: '#0d686f',
            borderColor: '#0d686f'
          }
        }
      }
    }

  }

  myChart.setOption({
    baseOption: baseOption,
    options: options
  });
  if ($.inArray(myChart, chartArray) == -1) {
    chartArray.push(myChart);
  }
  if (clickType === "maxRightClick") {
    if ($.inArray(myChart, rightMaxChartArray) == -1) {
      rightMaxChartArray.push(myChart);
    }
  }
  if (win != "") {
    win.resizecbfn(function () {
      myChart.resize();
      var width = $("#" + domId).width();
      var height = $("#" + domId).height();
      var gridWidth = width - 160;
      var gridHeight = height - 60;
      if (win.getState() == 'max')
        gridHeight = height - 20;
      baseOption.graphic[0].style.width = gridWidth;
      baseOption.graphic[0].style.height = gridHeight;
      myChart.setOption({
        baseOption: baseOption,
        options: options
      });
    });
  }
  return myChart.getDataURL({
    type: "png",
    backgroundColor: "rgba(18, 51, 51, 0.7)"
  });
}

var getMaxMinData = function (list) {
  var min = Math.min.apply(0, list),
    max = Math.max.apply(0, list);
  max = Math.round(max) + 1;
  min = Math.floor(min) - 1;
  return {
    min: min,
    max: max
  };
}

var getMarkPointData = function (list, xMin, _scale) {
  var data = new Array(),
    values = new Array(),
    scale = _scale || 10;
  if (list && list.length > 0) {
    for (var i = 0; i < list.length; i++) {
      var point = list[i];
      values.push(point.value);
      for (var j = 0; j < values.length; j++) {
        if (point.value != values[j] && point.value < values[j] + 2 && point.value > values[j] - 2) {
          xMin = xMin - scale;
          break;
        }
      }
      if (xMin < 5)
        xMin = 5; //console.log(point.name);console.log(xMin);console.log(point.value);
      data = data.concat(createMarkPoint(xMin, point.value, point.name));
    }
  }
  return data;
}

var createMarkPoint = function (x, y, name) {
  var data = new Array(),
    w = 110,
    symbolOffset = ['-230%', '-50%'];
  if (name.length > 4) {
    w = w + (name.length - 4) * 10;
    symbolOffset = ['-250%', '-50%'];
  }
  if (name != '坝顶高程' && name != '坝底高程') {
    data.push({
      symbol: "triangle",
      symbolSize: [12, 12],
      symbolOffset: symbolOffset,
      symbolRotate: 180,
      itemStyle: {
        normal: {
          color: "#8164A3"
        }
      },
      coord: [x, y],
      label: {
        normal: {
          show: false
        }
      }
    });
  }
  data.push({
    symbol: "roundRect",
    symbolSize: [w, 15],
    symbolOffset: ['30%', '-50%'],
    itemStyle: {
      normal: {
        color: "#8164A3"
      }
    },
    coord: [x, y],
    label: {
      normal: {
        show: true,
        position: 'insideBottom',
        formatter: function (param) {
          return name + ':' + param.data.coord[1] + 'm';
        }
      }
    }
  });
  return data;
}

var getOptions = function (data, xLineList, minY, xVminY) {
  var options = new Array();
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0) {
    var zs = data.zs.zsList;
    for (var i = 0; i < zs.length; i++) {
      var zObj = zs[i];
      var waterLine = new Array();
      xLineList.forEach(function (value, index, array) {
        waterLine.push([value, zObj.z]);
      })
      var markPointData = createMarkPoint(xVminY, zObj.z, '水位');
      if (zObj.q)
        markPointData.push({
          symbol: "rect",
          symbolSize: [120, 18],
          symbolOffset: ['30%', '50%'],
          itemStyle: {
            normal: {
              color: "#8164A3"
            }
          },
          coord: [xVminY, minY],
          Q: zObj.q,
          label: {
            normal: {
              show: true,
              formatter: function (param) {
                return '流量:' + param.data.Q + 'm³/s';
              }
            }
          }
        });
      var option = {};
      option.series = [{
        name: 'z',
        markPoint: {
          silent: true,
          data: markPointData
        },
        z: 2
      }, {
        type: 'line',
        name: 'waterLine',
        itemStyle: {
          normal: {
            opacity: 0
          }
        },
        areaStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        lineStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        data: waterLine,
        z: 0
      }];
      var textVal = '';
      if (zObj.tm)
        textVal += '时间:' + zObj.tm + "\n";
      else
        textVal += '时间:';
      if (textVal.length > 0) {
        option.graphic = [{
          type: 'group',
          id: 'textGroup',
          top: 10,
          left: 'center',
          children: [
            /*                        {
                         type: 'rect',
                         z: 10,
                         top: 'middle',
                         left: 'center',
                         shape: {
                         width: 180,
                         height: 20
                         },
                         style: {
                         fill: '#fff',
                         stroke: '#999',
                         lineWidth: 2,
                         shadowBlur: 8,
                         shadowOffsetX: 3,
                         shadowOffsetY: 3,
                         shadowColor: 'rgba(0,0,0,0.3)'
                         }
                         },*/
            {
              type: 'text',
              id: 'nowState',
              z: 11,
              top: 0,
              left: 'center',
              silent: true,
              style: {
                text: textVal,
                fill: '#FFF'
              }
            }
          ]
        }];
      }
      ;
      options.push(option);
    }
  }
  return options;
}
//手机页面 横断面
var createSectionViewPhone = function (domId, data) {
  if (!data.pointArr || data.pointArr.length == 0)
    return;
  var myChart = echarts.init(document.getElementById(domId));

  var tempList = new Array();
  var xLineList = new Array();
  for (var i = 0; i < data.pointArr.length; i++) {
    tempList.push(data.pointArr[i][1]);
    xLineList.push(data.pointArr[i][0]);
  }
  var maxMinY = getMaxMinData(tempList);

  var xVminY = 0;
  var tempMin = Math.min.apply(0, tempList);
  for (var i = 0; i < data.pointArr.length; i++) {
    if (data.pointArr[i][1] == tempMin)
      xVminY = data.pointArr[i][0];
  }

  var timeLineLabels = new Array();
  var timeLineIndex = 0,
    hasMax = false;
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0) {
    for (var i = 0; i < data.zs.zsList.length; i++) {
      if (data.zs.zsList[i].tm == data.zs.publishTm)
        timeLineIndex = i;
      var tempObj = {
        value: data.zs.zsList[i].tm,
        tooltip: {
          formatter: function (params) {
            return '{b}';
          }
        },
        symbol: 'rect',
        symbolSize: 5
      };
      if (data.zs.zsList[i].start) {
        tempObj.symbolSize = 15;
        tempObj.symbol = 'diamond';
      }
      if (data.zs.maxZ && data.zs.maxZ == data.zs.zsList[i].z && moment(data.zs.zsList[i].tm).isAfter(data.zs.publishTm) && !hasMax) {
        hasMax = true;
        tempObj.symbolSize = 15;
        tempObj.symbol = 'triangle';
        tempObj.tooltip = {
          formatter: function (params) {
            return '{b} 最高水位:' + data.zs.maxZ;
          }
        };
      }
      timeLineLabels.push(tempObj);
    }
  }

  var markPointData = getMarkPointData(data.pointList, xVminY);

  var winBodyWidth = $("#" + domId).width() - 10 - 150;
  var winBodyHeight = $("#" + domId).height() - 10 - 80;
  var _scaleX = 0,
    _scaleY = 0;
  if (data.pointArr[data.pointArr.length - 1][0] % 10 > 0) {
    _scaleX = Math.floor(data.pointArr[data.pointArr.length - 1][0] / 10) + (data.pointArr[data.pointArr.length - 1][0] % 10) / 10;
  } else {
    _scaleX = data.pointArr[data.pointArr.length - 1][0] / 10;
  }
  ;
  if ((maxMinY.max - maxMinY.min) % 10 > 0) {
    _scaleY = Math.floor((maxMinY.max - maxMinY.min) / 10) + ((maxMinY.max - maxMinY.min) % 10) / 10;
  } else {
    _scaleY = (maxMinY.max - maxMinY.min) / 10;
  }
  ;
  var _height = (winBodyWidth / _scaleX) * _scaleY;
  var baseOption = {
    grid: {
      // left:75,
      // right:75,
      // width:winBodyWidth,
      // height:_height,
      // top: (winBodyHeight-_height)/2
      bottom: 80
    },
    xAxis: {
      name: '起点距(m)',
      splitLine: {
        show: false
      },
      // axisLabel:{show:false},
      // axisTick:{show:false},
      boundaryGap: false,
      //interval:10,
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    yAxis: {
      name: '高程(m)',
      max: maxMinY.max,
      min: maxMinY.min,
      //interval:10,
      splitLine: {
        show: false
      },
      nameTextStyle: {
        color: '#FFF'
      },
      axisLine: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisTick: {
        lineStyle: {
          color: '#FFF'
        }
      },
      axisLabel: {
        textStyle: {
          color: '#FFF'
        }
      },
    },
    series: [{
      type: 'line',
      name: 'sectionLine',
      itemStyle: {
        normal: {
          opacity: 0
        }
      },
      areaStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      lineStyle: {
        normal: {
          color: '#bdb1b1',
          opacity: 1
        }
      },
      data: data.pointArr,
      z: 1
    }, {
      type: 'line',
      name: 'index',
      markPoint: {
        silent: true,
        data: markPointData
      },
      z: 2
    }],
    //backgroundColor:"rgba(0, 102, 204, 0.3)"
  };
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0)
    baseOption.timeline = {
      axisType: 'category',
      autoPlay: false,
      playInterval: 1000,
      currentIndex: timeLineIndex,
      bottom: 0,
      data: timeLineLabels,
      label: {
        formatter: function (param) {
          return param;
        },
        textStyle: {
          color: '#FFF'
        }
      },
      lineStyle: {
        color: '#FFF',
        width: 0.5
      },
      controlStyle: {
        normal: {
          color: '#FFF',
          borderColor: '#FFF'
        }
      },
      itemStyle: {
        normal: {
          color: '#FFF',
          borderColor: '#FFF'
        }
      }
    }
  var options = getOptions(data, xLineList, tempMin, xVminY);
  myChart.setOption({
    baseOption: baseOption,
    options: options
  });

}

var convertNumber = function (_num) {
  switch (parseInt(_num)) {
    case 1:
      _num = "I";
      break;
    case 2:
      _num = "II";
      break;
    case 3:
      _num = "III";
      break;
    case 4:
      _num = "IV";
      break;
    default:
      break;
  }
  ;
  return _num;
}

//检查浏览器
var checkBrowser = function () {
  var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
  var isOpera = userAgent.indexOf("Opera") > -1;
  if (isOpera) {
    return "Opera"
  }
  ; //判断是否Opera浏览器
  if (userAgent.indexOf("Firefox") > -1) {
    return "Firefox";
  } //判断是否Firefox浏览器
  if (userAgent.indexOf("Chrome") > -1) {
    return "Chrome";
  }
  if (userAgent.indexOf("Safari") > -1) {
    return "Safari";
  } //判断是否Safari浏览器
  if (userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera) {
    return "IE";
  }
  ; //判断是否IE浏览器
}
//检查操作系统
var checkOs = function () {
  var sUserAgent = navigator.userAgent;
  var isWin = (navigator.platform == "Win32") || (navigator.platform == "Windows");
  var isMac = (navigator.platform == "Mac68K") || (navigator.platform == "MacPPC") || (navigator.platform == "Macintosh") || (navigator.platform == "MacIntel");
  if (isMac) return "Mac";
  var isUnix = (navigator.platform == "X11") && !isWin && !isMac;
  if (isUnix) return "Unix";
  var isLinux = (String(navigator.platform).indexOf("Linux") > -1);
  if (isLinux) return "Linux";
  if (isWin) {
    var isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
    if (isWin2K) return "Win2000";
    var isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
    if (isWinXP) return "WinXP";
    var isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
    if (isWin2003) return "Win2003";
    var isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
    if (isWinVista) return "WinVista";
    var isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
    if (isWin7) return "Win7";
  }
  return "other";
}
//判断手机号
var checkPhone = function (phone) {
  if (!(/^1(3|4|5|7|8)\d{9}$/.test(phone))) {
    return false;
  } else {
    return true;
  }
}

//判断flash
function flashChecker() {
  var hasFlash = 0; //是否安装了flash
  var flashVersion = 0; //flash版本
  var isIE = /*@cc_on!@*/ 0; //是否IE浏览器

  if (isIE) {
    var swf = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
    if (swf) {
      hasFlash = 1;
      VSwf = swf.GetVariable("$version");
      flashVersion = parseInt(VSwf.split(" ")[1].split(",")[0]);
    }
  } else {
    if (navigator.plugins && navigator.plugins.length > 0) {
      var swf = navigator.plugins["Shockwave Flash"];
      if (swf) {
        if (swf.filename == 'internal-not-yet-present') {
          hasFlash = 0;
        } else {
          hasFlash = 1;
          var words = swf.description.split(" ");
          for (var i = 0; i < words.length; ++i) {
            if (isNaN(parseInt(words[i]))) continue;
            flashVersion = parseInt(words[i]);
          }
        }
      }
    }
  }
  return {
    f: hasFlash,
    v: flashVersion
  };
}

//base64编码图片转blob
function convertImgDataToBlob(base64Data) {
  var format = "image/png";
  var base64 = base64Data;
  var code = window.atob(base64.split(",")[1]);
  var aBuffer = new window.ArrayBuffer(code.length);
  var uBuffer = new window.Uint8Array(aBuffer);
  for (var i = 0; i < code.length; i++) {
    uBuffer[i] = code.charCodeAt(i) & 0xff;
  }
  var blob = null;
  try {
    blob = new Blob([uBuffer], {
      type: format
    });
  } catch (e) {
    window.BlobBuilder = window.BlobBuilder ||
      window.WebKitBlobBuilder ||
      window.MozBlobBuilder ||
      window.MSBlobBuilder;
    if (e.name == 'TypeError' && window.BlobBuilder) {
      var bb = new window.BlobBuilder();
      bb.append(uBuffer.buffer);
      blob = bb.getBlob("image/png");

    } else if (e.name == "InvalidStateError") {
      blob = new Blob([aBuffer], {
        type: format
      });
    } else {

    }
  }
  return blob;

};

//上传blob文件
function sendPointBlobFile(params, done) {
  //创建formData对象
  var formData = new FormData();
  var blobBin = params.blobData;
  var url = params.url;
  if (blobBin) {
    formData.append('file', blobBin);
    formData.append('fileType', ".png");
  }
  //上传数据
  $.ajax({
    url: url,
    type: 'post',
    processData: false,
    contentType: false,
    data: formData,
    dataType: 'json',
    success: function (data) {
      done(null, data)
    },
    error: function (jqXHR, textStatus, errorThrown) {
      done('上传失败', null);
    }
  });
}

var createDamViewNew = function (domId, data, win) {
  var myChart = echarts.init(document.getElementById(domId));
  var markPointData = getMarkPointData(data.pointList, 35);
  //markPointData = markPointData.concat(createMarkPoint(55, data.min, '坝底高程'));

  var damImg = '/images/dam/00.png';
  var width = $("#" + domId).width();
  var height = $("#" + domId).height();
  var gridWidth = width - 260;
  var gridHeight = height,
    oldMax = data.max,
    elXVal = 62,
    yPu = 0.334,
    yPd = 0.2,
    waterLen = 54.8;
  markPointData = markPointData.concat(createMarkPoint(elXVal, data.max, '坝顶高程'));
  //console.log(data.type);

  data.min = parseInt(data.min - (data.max - data.min) * yPd);
  data.max = parseInt(data.max + (yPu * (data.max - data.min) / (1 - yPu)));

  var pxV = ""
  if (win == "") {
    //switch (data.type){
    //    case 0:
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 1://OK
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 2:
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 3://OK
    //        pxV= (height+20)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 4:
    //        pxV= (height+20)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 5://OK
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 6:
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 7:
    //        pxV= (height+150)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 8://OK
    //        pxV= (height+20)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    case 9:
    //        pxV= (height+20)/(data.max-data.min);//刻度转换像素  1刻度=pxV像素
    //        break;
    //    default:
    //        break;
    //}
  } else {
    pxV = (height) / (data.max - data.min); //刻度转换像素  1刻度=pxV像素
  }
  gridHeight = (oldMax - data.min) * pxV;
  var baseOption = ""
  if (win == "") {
    baseOption = {
      grid: {
        left: 80,
        right: 0,
        bottom: 0,
        top: 0
      },
      backgroundColor: "rgba(18, 51, 51, 0.7)",
      xAxis: {
        splitLine: {
          show: false
        },
        min: 0,
        max: 100,
        boundaryGap: false,
        axisTick: false, //是否显示刻度
        axisLabel: false, //是否显示刻度标签
        nameTextStyle: {
          color: '#FFF'
        }
      },
      yAxis: {
        name: '高程(m)',
        max: data.max,
        min: data.min,
        splitLine: {
          show: false
        },
        nameTextStyle: {
          color: '#FFF',
          fontSize: 10
        },
        axisLine: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisTick: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisLabel: {
          textStyle: {
            color: '#FFF'
          }
        },
      },
      series: [{
        type: 'line',
        name: 'index',
        markPoint: {
          silent: true,
          data: markPointData
        },
        z: 3
      }, {
        name: 'waterLine',
        type: 'line',
        symbolSize: 0,
        areaStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        lineStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        z: 0
      }],
      graphic: [{
        type: 'image',
        id: 'logo',
        left: 1,
        bottom: 1,
        z: 1,
        bounding: 'raw',
        style: {
          image: damImg,
          width: gridWidth,
          height: gridHeight,
          opacity: 1
        }
      }]
    };
  } else {
    baseOption = {
      grid: {
        left: 40,
        right: 0,
        bottom: 2,
        top: 0
      },
      backgroundColor: "rgba(18, 51, 51, 0.7)",
      xAxis: {
        splitLine: {
          show: false
        },
        min: 0,
        max: 100,
        boundaryGap: false,
        axisTick: false, //是否显示刻度
        axisLabel: false, //是否显示刻度标签
        nameTextStyle: {
          color: '#FFF'
        }
      },
      yAxis: {
        name: '高程(m)',
        max: data.max,
        min: data.min,
        splitLine: {
          show: false
        },
        nameTextStyle: {
          color: '#FFF',
          fontSize: 10
        },
        axisLine: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisTick: {
          lineStyle: {
            color: '#FFF'
          }
        },
        axisLabel: {
          textStyle: {
            color: '#FFF'
          }
        },
      },
      series: [{
        type: 'line',
        name: 'index',
        markPoint: {
          silent: true,
          data: markPointData
        },
        z: 3
      }, {
        name: 'waterLine',
        type: 'line',
        symbolSize: 0,
        areaStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        lineStyle: {
          normal: {
            color: '#1f9cff'
          }
        },
        z: 0
      }],
      graphic: [{
        type: 'image',
        id: 'logo',
        left: 2,
        bottom: 2,
        z: 1,
        bounding: 'raw',
        style: {
          image: damImg,
          width: gridWidth,
          height: gridHeight,
          opacity: 1
        }
      }]
    };
  }


  var options = new Array();
  if (data.zs && data.zs.zsList && data.zs.zsList.length > 0) {
    var tLabel = new Array(),
      textVal = '',
      timeLineIndex = 0,
      timeLineMarkPointData, hasMax = false;
    data.zs.zsList.forEach(function (value, index, array) {
      timeLineMarkPointData = markPointData;
      //if(value.tm == data.zs.publishTm)
      timeLineIndex = index;
      var tempObj = {
        value: value.tm,
        tooltip: {
          formatter: function (params) {
            return params.name;
          }
        },
        symbol: 'rect',
        symbolSize: 5
      };
      if (value.start) {
        tempObj.symbolSize = 15;
        tempObj.symbol = 'diamond';
      }
      if (data.zs.maxZ && data.zs.maxZ == value.z && moment(value.tm).isAfter(data.zs.publishTm) && !hasMax) {
        hasMax = true;
        tempObj.symbolSize = 15;
        tempObj.symbol = 'triangle';
        tempObj.tooltip = {
          formatter: function (params) {
            return params.name + ' 最高水位:' + data.zs.maxZ + 'm';
          }
        };
        tempObj.itemStyle = {
          normal: {
            color: 'rgba(31, 156, 255, 1)'
          }
        };
      }
      tLabel.push(tempObj);

      timeLineMarkPointData = timeLineMarkPointData.concat(createMarkPoint(5, value.z, '水库水位'));
      timeLineMarkPointData.push({
        symbol: "rect",
        symbolSize: [130, 18],
        itemStyle: {
          normal: {
            color: 'rgba(128, 128, 128, 0)'
          }
        },
        coord: [20, value.z - (value.z - data.min) / 2],
        W: value.w,
        label: {
          normal: {
            show: true,
            formatter: function (param) {
              return '库容:' + param.data.W + '万m³';
            }
          }
        }
      });
      timeLineMarkPointData.push({
        symbol: "rect",
        symbolSize: [130, 18],
        symbolOffset: [0, '-300%'],
        itemStyle: {
          normal: {
            color: 'rgba(128, 128, 128, 0)'
          }
        },
        coord: [50, data.max + 5],
        W: value.w,
        label: {
          normal: {
            show: true,
            formatter: function (param) {
              return '时间:' + value.tm;
            }
          }
        }
      });
      options.push({
        series: [{
          type: 'line',
          name: 'nowZ',
          markPoint: {
            silent: true,
            data: timeLineMarkPointData
          },
          z: 3
        }, {
          name: 'waterLine',
          data: [
            [0, value.z],
            [waterLen, value.z]
          ]
        }]
      });
    });
    baseOption.tooltip = {};
    baseOption.timeline = {
      axisType: 'category',
      autoPlay: false,
      playInterval: 1000,
      bottom: 10,
      currentIndex: timeLineIndex,
      data: tLabel,
      left: 80,
      right: 80,
      z: 10,
      label: {
        formatter: function (param) {
          return param;
        },
        textStyle: {
          color: '#0d686f'
        }
      },
      lineStyle: {
        color: '#0d686f'
      },
      controlStyle: {
        normal: {
          color: '#0d686f',
          borderColor: '#0d686f'
        }
      },
      itemStyle: {
        normal: {
          color: '#0d686f',
          borderColor: '#0d686f'
        }
      }
    }
  }

  myChart.setOption({
    baseOption: baseOption,
    options: options
  });
  if (win != "") {
    win.resizecbfn(function () {
      myChart.resize();
      var width = $("#" + domId).width();
      var height = $("#" + domId).height();
      var gridWidth = width - 160;
      var gridHeight = height - 60;
      if (win.getState() == 'max')
        gridHeight = height - 20;
      baseOption.graphic[0].style.width = gridWidth;
      baseOption.graphic[0].style.height = gridHeight;
      myChart.setOption({
        baseOption: baseOption,
        options: options
      });
    });
  }
  return myChart.getDataURL({
    type: "png",
    backgroundColor: "rgba(18, 51, 51, 0.7)"
  });
}

//交换数组指定位置
function arrayDataChange(arr, k, j) {
  var c = arr[k];
  arr[k] = arr[j];
  arr[j] = c;
}

function getSystemTime() {
  return Date.now() - (LOCAL_TIME - SYSTEM_TIME);
}

var checkStation;
$(function () {
  setTimeout(() => {
    ajaxCallJson({}, "/system/time", (res) => {
      if (res.resflag) {
        SYSTEM_TIME = res.data;
        LOCAL_TIME = Date.now();
      }
    });
  }, 3000);
});
