/**
 * Extends system object or class.
 *
 * @version 1.2
 * @update 2018.01.23.
 *
 * Created by Alice on 2016.12.23.
 */
function defineProperty(object, name, option, override) {
  if (!(name in object) || override) {
    Object.defineProperty(object, name, option);
  }
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
defineProperty(Object, "get", {
  value: function (model, key, def) {
    if (!model || !key) return def;
    let start = 0, end;
    let owner = model;
    while (true) {
      end = key.indexOf(".", start);
      if (end < 0) {
        let val = start === 0 ? owner[key] : owner[key.substring(start)];
        return val == null ? def : val;
      }
      let name = key.substring(start, end);
      owner = owner[name];
      start = end + 1;
      if (owner == null) return def;
    }
  }
});
defineProperty(Object, "set", {
  value: function (model, key, value) {
    if (model == null || key == null) return;
    let start = 0, end;
    let owner = model;
    while (true) {
      end = key.indexOf(".", start);
      if (end < 0) {
        owner[start === 0 ? key : key.substring(start)] = value;
        break;
      }
      let name = key.substring(start, end);
      let get = owner[name];
      owner = (get == null) ? (owner[name] = {}) : get;
      start = end + 1;
    }
    return model;
  }
});

defineProperty(Object, "free", {
    value: function (target) {
      if (target == null) return;
      for (let name in target) {
        let value = target[name];
        if (Object.ordinary(value) || Array.isArray(value)) {
          Object.free(value);
        }
        delete target[name];
      }
    }
  }
);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const PLAIN_OBJECT = {};
defineProperty(Object, "ordinary", {
    value: function (target) {
      let proto, Ctor;

      // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects
      if (!target || toString.call(target) !== "[object Object]") {
        return false;
      }

      proto = Object.getPrototypeOf(target);

      // Objects with no prototype (e.g., `Object.create( null )`) are plain
      if (!proto) return true;


      // Objects with prototype are plain iff they were constructed by a global Object function
      Ctor = PLAIN_OBJECT.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && PLAIN_OBJECT.toString.call(Ctor) === PLAIN_OBJECT.toString.call(Object);
    }
  }
);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 *
 * @param target {Object|Array}
 * @param source {Object|Array}
 * @return {Object|Array}
 */
function clone(target, source) {
  for (let name in source) {
    let src = target[name], copy = source[name];
    if (target === copy) continue;
    if (copy && Object.ordinary(copy)) {
      target[name] = clone(Object.ordinary(src) ? src : {}, copy);
    } else if (copy && Array.isArray(copy)) {
      target[name] = clone(Array.isArray(src) ? src : [], copy);
    } else if (copy !== undefined) {
      target[name] = copy;
    }
  }
  return target;
}

/**
 * Deep clone an object from given sources.
 *
 * @param target {Object|Array}
 * @param sources {*}
 * @return {Object|Array}
 */
defineProperty(Object, "assigns", {
    value: function (target, ...sources) {
      sources.forEach(e => clone(target, e));
      return target;
    }
  }
);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 * Extend attributes from some object(owner).
 *
 * @param source {Object}
 * @param owner {Object}
 * @param extend {String}
 * @param target {Object}
 * @return {Object}
 */
defineProperty(Object, "extends", {
  value: function (source, owner, extend = "extends", target = {}) {
    target = Object.assigns(target, source);
    if (target[extend]) {
      let name = target[extend];
      delete target[extend];
      return Object.extends(target, owner, extend, owner[name]);
    }
    return target;
  }
});
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 * Convert object's attributes to array.
 *
 * @param object {Object}
 * @param filter {Function?} Accept two parameters,witch is 'name' and the 'object'.
 *        The function mast be return the value. Return 'undefined' to skip.
 * @return {Array}
 */
defineProperty(Object, "array", {
  value: function (object, filter) {
    if (object == null) return [];
    let items = [];
    for (let name in object) {
      let ret = filter ? filter(object[name], name, object) : object[name];
      if (ret !== undefined) items.push(ret);
    }
    return items;
  }
});

defineProperty(Object, "each", {
  value: function (object, filter, owner, order) {
    if (Array.isArray(object)) {
      if (order === false) {
        for (let i = object.length - 1; i >= 0; i--) {
          filter.call(owner, object[i], i, object);
        }
      } else {
        object.forEach(filter, owner);
      }
    } else {
      for (let name in object) {
        filter.call(owner, object[name], name, object);
      }
    }
    return object;
  }
});

defineProperty(Object, "pack", {
  value: function (array, accept, filter) {
    if (!Array.isArray(array)) return accept;
    for (let name in array) {
      filter.call(array, array[name], name, accept);
    }
    return accept;
  }
});

/**
 * Test has specify item.
 */
defineProperty(Array.prototype, "contains", {
  enumerable: false,
  value: function (item) {

    return this.indexOf(item) > -1;
  }
});


/**
 * Insert item by index.
 */
defineProperty(Array.prototype, "insert", {
  enumerable: false,
  value: function (item, index = 0) {
    this.splice(index, 0, item);
    return this;
  }
});

/**
 * Remove an element form array by given index.
 */
defineProperty(Array.prototype, "remove0", {
  enumerable: false,
  value: function (index, count = 1) {
    if (isNaN(index) || index > this.length) {
      return this;
    }
    if (index > -1 && index < this.length) {
      this.splice(index, count);
    }
    return this;
  }
});

/**
 * Remove an element form array by given index.
 */
defineProperty(Array.prototype, "removeIf", {
  enumerable: false,
  value: function (filter) {
    let size = this.length;
    for (let i = 0; i < size; i++) {
      if (filter(this[i])) {
        return this.remove0(i);
      }
    }
    return this;
  }
});

/**
 * Remove an element from array by value.
 * @param val the value to delete
 * @param form begin index.
 *
 */
defineProperty(Array.prototype, "delete", {
  enumerable: false,
  value: function (val, from) {
    let index = this.indexOf(val, from);
    if (index >= 0) {
      this.remove0(index);
    }
    return this;
  }
});

/**
 * Clean all element from array.
 */
defineProperty(Array.prototype, "clear", {
    enumerable: false,
    value: function () {
      this.splice(0, this.length);
      return this;
    }
  }
);

/**
 * Remove elements from filter.
 */
defineProperty(Array.prototype, "clearIf", {
  enumerable: false,
  value: function (filter) {
    let indices = [];
    let size = this.length;
    for (let i = 0; i < size; i++) {
      if (filter(this[i])) indices.push(i);
    }
    if (indices.length) {
      for (let i = indices.length - 1; i >= 0; i--) {
        this.splice(indices[i], 1);
      }
    }
    return this;
  }
});


defineProperty(Array.prototype, "find", {
    enumerable: false,
    value: function (filter) {
      for (let i = this.length - 1; i >= 0; i--) {
        if (filter(this[i])) {
          return this[i];
        }
      }
      return null;
    }
  }
);

/**
 * Append items in array.
 */
// defineProperty(Array.prototype, "append", {
//     enumerable: false,
//     value: function (items, clean) {
//       if (this === items) return;
//       if (clean === true) this.clear();

//       let size = (items && items.length) || 0;
//       if (size === 0) return;

//       for (let i = 0; i < size; i++) {
//         this.push(items[i]);
//       }
//       return this;
//     }
//   }
// );
/**
 * Clean old data and append new data.
 */
defineProperty(Array.prototype, "seize", {
    enumerable: false,
    value: function (items) {
      return this.append(items, true);
    }
  }
);


/**
 * Get new an array from given key.
 *
 * The key can be those value.
 * <ul>
 *     <li>A String: as object property, like this: 'address.city'</li>
 * </ul>
 *
 *  If you has any question, see this implement.
 *
 * @param The given key.
 */
defineProperty(Array.prototype, "collect", {
    enumerable: false,
    value: function (key) {
      let ret = [], size = this.length;
      for (let i = 0; i < size; i++) {
        ret[i] = Object.get(this[i], key);
      }
      return ret;
    }
  }
);

defineProperty(Array.prototype, "fill", {
    enumerable: false,
    value: function (val) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = val;
      }
      return this;
    }
  }
);
defineProperty(Array.prototype, "clone", {
    enumerable: false,
    value: function () {
      return this.slice();
    }
  }
);

defineProperty(Array.prototype, "isEmpty", {
    enumerable: false,
    get: function () {
      return this.length === 0;
    }
  }
);

defineProperty(Array.prototype, "notEmpty", {
    enumerable: false,
    get: function () {
      return this.length > 0;
    }
  }
);

defineProperty(Array.prototype, "last", {
    enumerable: false,
    get: function () {
      return this[this.length - 1];
    }
  }
);
defineProperty(Array.prototype, "first", {
    enumerable: false,
    get: function () {
      return this[0];
    }
  }
);

/**
 * Group a list to map by given key.
 *
 */
defineProperty(Array.prototype, "group", {
    enumerable: false,
    value: function (key) {
      let map = new Map();
      this.forEach(function (e) {
        let value = e[key];
        if (!map.has(value)) map.set(value, []);
        map.get(value).push(e);
      });
      return map;
    }
  }
);

defineProperty(Array.prototype, "pushIf", {
    enumerable: false,
    value: function (value) {
      if (this.indexOf(value) < 0) this.push(value);
      return this;
    }
  }
);

/**
 * Replace target to value, whatever target exists, the value will add in array.
 */
defineProperty(Array.prototype, "replace", {
    enumerable: false,
    value: function (target, value) {
      this.delete(target);
      return this.pushIf(value);
    }
  }
);

/**
 * Replace target to value, whatever target exists, the value will add in array.
 */
defineProperty(Array.prototype, "switch", {
    enumerable: false,
    value: function (value, condition) {
      if (condition === false) return this.delete(value);
      if (condition === true) return this.pushIf(value);
    }
  }
);

defineProperty(Array.prototype, "max", {
    enumerable: false,
    value: function () {
      let max = this.last;
      for (let i = this.length - 2; i >= 0; i--) {
        if (max == null || this[i] > max) max = this[i];
      }
      return max;
    }
  }
);

defineProperty(Array.prototype, "min", {
    enumerable: false,
    value: function () {
      let min = this.last;
      for (let i = this.length - 2; i >= 0; i--) {
        if (min == null || this[i] < min) min = this[i];
      }
      return min;
    }
  }
);

/**
 * Make an new array from given condition.
 *
 * The argument 'start' and argument end has second means.
 *
 * If 'end' &lt; 0, then start is fill value and end is new array size.
 * Else, return a sequence array start by 'start' and end by 'end'(exclusive).
 *
 * @params start The start value
 */
defineProperty(Array, "make", {
    enumerable: false,
    value: function (start, end) {
      if (start < 0) {
        return new Array(-start).fill(end);
      }
      let ret = [];
      for (let i = start; i < end; i++) {
        ret.push(i);
      }
      return ret;
    }
  }
);


/**
 * Ensure an array to return.
 *
 * @param target {Array,Object}
 * @return {Array}
 */
defineProperty(Array, "ensure", {
  value: function (target) {
    return target == null ? null : Array.isArray(target) ? target : [target];
  }
});


/**
 * Extends a method of Boolean object for test a value is boolean type or not.
 */
defineProperty(Boolean, "is", {
    value: function (value) {
      return typeof value === "boolean" || value instanceof Boolean;
    }
  }
);

/**
 * Extends a method of Boolean object for test a value is boolean type or not.
 */
defineProperty(Boolean, "not", {
    value: function (value) {
      return !Boolean.is(value);
    }
  }
);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**
 * Extends a method that name's boolOf(value,default).
 * Except two parameter. Fist is string and second is bool.
 * If first parameter is [undefined | null | ''], then return second parameter(default value).
 * If fist parameter is 'TRUE' or 'true', then return true. Else return false.
 */
defineProperty(Boolean, "boolOf", {
    value: function (value, def) {
      if (!value || value.trim() === "") {
        return !!def;
      }
      return value.toLowerCase() === "true";
    }
  }
);


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 * Test the argument is function or not.
 * @param argument {*}
 * @return boolean
 */
defineProperty(Function, "is", {
    value: function (argument) {
      return argument instanceof Function;
    }
  }
);

/**
 * Delete (count) string from some index.
 * @params start start index.
 * @params len delete count.
 */
defineProperty(String.prototype, "delete", {
    value: function (start, len) {
      return this.substring(0, start) + this.substring(start + len, this.length);
    }
  }
);
/**
 * Delete string by index between start and end.
 * @params start The beginning index, inclusive.
 * @params end The ending index, exclusive.
 */
defineProperty(String.prototype, "deleteAt", {
    value: function (start, end) {
      return this.substring(0, start) + this.substring(end, this.length);
    }
  }
);

/**
 * Replace string to new map at index between start and end.
 *
 * @params start The beginning index, inclusive.
 * @params end The ending index, exclusive.
 * @params str   String that will replace contents.
 */
defineProperty(String.prototype, "replaceAt", {
    value: function (start, end, content) {
      return this.substring(0, start) + content + this.substring(end, this.length);
    }
  }
);

/**
 * Replace start to new map at index to length.
 *
 * @params start The beginning index inclusive.
 * @params length The length to replace.
 * @params map The new map for replace.
 */
defineProperty(String.prototype, "replaceBy", {
    value: function (start, length, content) {
      return this.replaceAt(start, start + length, content);
    }
  }
);

defineProperty(String.prototype, "insert", {
    value: function (index, value) {
      if (index > this.length) {
        return this.concat(value);
      }
      return this.replace(new RegExp("(.{" + index + "})"), "$1" + value);
    }
  }
);


defineProperty(String.prototype, "contains", {
    value: function (content, from) {
      return this.indexOf(content, from) >= 0;
    }
  }
);


defineProperty(String, "is", {
    value: function (value) {
      return value === null || value === undefined ? false
        : (typeof value === "string") || (value instanceof String);
    }
  }
);

defineProperty(String, "isEmpty", {
  value: function (value) {
    return (value === null || value === undefined || value.length === 0);
  }
});

defineProperty(String, "notEmpty", {
  value: function (value) {
    return !String.isEmpty(value);
  }
});

defineProperty(String, "isBlank", {
    value: function (value) {
      return (this.isEmpty(value) || value.match(/^\s*$/));
    }
  }
);
defineProperty(String, "trim", {
    value: function (value) {

      return String.is(value) ? value.trim() : value;
    }
  }
);

/**
 * Return a string.
 * If value is null return def or 'null';
 * If value is undefined return def or 'undefined';
 * Else return value.toString();
 */
defineProperty(String, "valueBy", {
    value: function (value, def) {
      if (value === null) {
        return def || "null";
      }
      if (value === undefined) {
        return def || "undefined";
      }
      return value.toString();
    }
  }
);

